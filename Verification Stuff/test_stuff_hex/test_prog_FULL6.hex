// --- Initialization ---
00100093 // ADDI  x1, x0, 1      ; x1 = 1
fff00113 // ADDI  x2, x0, -1     ; x2 = -1 (0xFFFFFFFF)
000001b7 // LUI   x3, 0x00000    ; x3 = 0 (Upper Immediate) 
00000197 // AUIPC x3, 0x00000    ; x3 = PC + 0 

// --- Store Instructions (S-Type) [cite: 30] ---
00100023 // SB    x1, 0(x0)      ; Store Byte (Mem[0] = 0x01)
00101023 // SH    x1, 0(x0)      ; Store Half (Mem[0] = 0x0001)
00102023 // SW    x1, 0(x0)      ; Store Word (Mem[0] = 0x00000001)

// --- Load Instructions (I-Type) [cite: 23] ---
00000203 // LB    x4, 0(x0)      ; Load Byte (Signed)
00001283 // LH    x5, 0(x0)      ; Load Half (Signed)
00002303 // LW    x6, 0(x0)      ; Load Word
00004383 // LBU   x7, 0(x0)      ; Load Byte Unsigned
00005403 // LHU   x8, 0(x0)      ; Load Half Unsigned

// --- ALU R-Type Instructions [cite: 17] ---
002084b3 // ADD   x9, x1, x2     ; 1 + (-1) = 0
40208533 // SUB   x10, x1, x2    ; 1 - (-1) = 2
002095b3 // SLL   x11, x1, x2    ; Shift Left Logical
0020a633 // SLT   x12, x1, x2    ; Set Less Than (Signed)
0020b6b3 // SLTU  x13, x1, x2    ; Set Less Than Unsigned
0020c733 // XOR   x14, x1, x2    ; XOR
0020d7b3 // SRL   x15, x1, x2    ; Shift Right Logical
4020d833 // SRA   x16, x1, x2    ; Shift Right Arithmetic
0020e8b3 // OR    x17, x1, x2    ; OR
0020f933 // AND   x18, x1, x2    ; AND

// --- ALU I-Type Instructions [cite: 23] ---
00108993 // ADDI  x19, x1, 1     ; Add Immediate
0010a993 // SLTI  x19, x1, 1     ; Set Less Than Imm
0010b993 // SLTIU x19, x1, 1     ; Set Less Than Imm Unsigned
0010c993 // XORI  x19, x1, 1     ; XOR Immediate
0010e993 // ORI   x19, x1, 1     ; OR Immediate
0010f993 // ANDI  x19, x1, 1     ; AND Immediate
00109993 // SLLI  x19, x1, 1     ; Shift Left Logical Imm
0010d993 // SRLI  x19, x1, 1     ; Shift Right Logical Imm
4010d993 // SRAI  x19, x1, 1     ; Shift Right Arith Imm

// --- Jump Instructions (J-Type & I-Type) [cite: 45, 65] ---
008000ef // JAL   x1, +8         ; Jump to PC+8 (Skip next NOP)
00000013 // NOP                  ; (Should be skipped)
00000097 // AUIPC x1, 0          ; Get current PC
00808067 // JALR  x0, x1, 8      ; Jump to PC+8 (Skip next NOP)
00000013 // NOP                  ; (Should be skipped)

// --- Branch Instructions (B-Type) [cite: 35] ---
// All branches below are TRUE and skip the following NOP
00000463 // BEQ   x0, x0, +8     ; Branch if Equal (0==0)
00000013 // NOP
00009463 // BNE   x1, x0, +8     ; Branch if Not Equal (1!=0)
00000013 // NOP
00104463 // BLT   x2, x1, +8     ; Branch Less Than (-1 < 1)
00000013 // NOP
0020d463 // BGE   x1, x2, +8     ; Branch Greater/Equal (1 >= -1)
00000013 // NOP
00206463 // BLTU  x1, x2, +8     ; Branch Less Than Unsigned (1 < -1u)
00000013 // NOP
0010f463 // BGEU  x2, x1, +8     ; Branch Greater/Equal Unsigned (-1u > 1)
00000013 // NOP